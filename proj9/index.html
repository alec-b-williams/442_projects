<!DOCTYPE html>
<html>
    <head>
        <style>
            #the-canvas { border: 1px solid darkblue; }
            body {background-color: black; color: white;}
        </style>
    </head>

    <body>
        <canvas id = "the-canvas" width = "800" height = "600"></canvas>
        <br>  
        <button onclick="projection.set_fov(-5)">--</button>
        <button onclick="projection.set_fov(-1)">-</button>
        <span id="fov_label"></span>
        <button onclick="projection.set_fov(1)">+</button>
        <button onclick="projection.set_fov(5)">++</button>
        <br>  
        <button onclick="update_dist(-.5)">--</button>
        <button onclick="update_dist(-.1)">-</button>
        <span id="dist_label"></span>
        <button onclick="update_dist(.1)">+</button>
        <button onclick="update_dist(.5)">++</button>
        <br>  
        <button onclick="projection.set_near(-.05)">--</button>
        <button onclick="projection.set_near(-.01)">-</button>
        <span id="near_label"></span>
        <button onclick="projection.set_near(.01)">+</button>
        <button onclick="projection.set_near(.05)">++</button>
        <br>
        <span id="keys_label"></span>
        <br>
        <button onclick="toggle_inversion()">toggle</button><span id="inversion_label"></span><br>
        <button onclick="toggle_fun()">toggle</button><span style="color:yellow;font-size:xx-large;" id="fun_label"></span><br>
        <span>Camera Position:</span><br>
        <span id="cam_x_label"></span><br>
        <span id="cam_y_label"></span><br>
        <span id="cam_z_label"></span><br>
        <span id="cam_roll_label"></span><br>
        <span id="cam_pitch_label"></span><br>
        <span id="cam_yaw_label"></span><br>  

        <script src = "src/lib.js"></script>
        <script src = "src/vector_lib.js"></script>
        <script src = "src/matrix_lib.js"></script>
        <script src = "src/mesh.js"></script>
        <script src = "src/input.js"></script>
        <script src = "src/model.js"></script>
        <script src = "src/view.js"></script>
        <script src = "src/projection.js"></script>
        <script src = "src/material.js"></script>
        <script src = "src/shaders.js"></script>
        <script src = "src/doc_util.js"></script>
        <script src = "src/node.js"></script>
        <script src = "src/render.js"></script>
                 
        <script>
            let canvas = document.getElementById( 'the-canvas' );
            
            /** @type {WebGLRenderingContext} */
            let gl = canvas.getContext( 'webgl2' );

            let shader_program = 
                create_compile_and_link_program( gl, Shaders.vertex_source, Shaders.fragment_source );

            const input = Keys.start_listening();
            const camera = new View(input);
            const projection = new Projection(input);

            const DESIRED_TICK_RATE = 60;
            const DESIRED_MSPT = 1000 / DESIRED_TICK_RATE;

            let last_update = performance.now();
            let total_delta = 0;

            let sun_dir = (new Vec4(1,0,0,0)).norm();
            let sun_color = [1,1,.85];

            let light_dist = 1;
            let fun = false;

            let point_linear_scale = 1.2;

            let metal_image = new Image();
            metal_image.src = "textures/earth.jpg";
            metal_image.onload = on_load;

            let root = new Node();

            let sphere = root.add_child();
            sphere.move_right(1);
            sphere.data = Mesh.uv_sphere(gl, shader_program, 32, new Material(.25, 1, 2, 4));

            let baby_sphere = sphere.add_child();
            baby_sphere.scale = new Vec4(.25,.25,.25,1);
            baby_sphere.move_right(.75);
            baby_sphere.data = Mesh.uv_sphere(gl, shader_program, 32, new Material(.25, 1, 2, 4));

            let other_sphere = root.add_child();
            other_sphere.move_left(1);
            other_sphere.data = Mesh.uv_sphere(gl, shader_program, 8, new Material(.25, 1, 2, 4));

            setInterval(update, DESIRED_MSPT);

            gl.cullFace( gl.BACK );
            gl.enable( gl.CULL_FACE );
            
            gl.useProgram( shader_program );

            let tex = gl.createTexture();
            gl.bindTexture( gl.TEXTURE_2D, tex );

            gl.texImage2D(
              gl.TEXTURE_2D, 0, gl.RGBA,
              256, 256, 0,
              gl.RGBA, gl.UNSIGNED_BYTE, 
              xor_texture()
            );

            gl.generateMipmap(gl.TEXTURE_2D);
            
            const sampler_loc = gl.getUniformLocation( shader_program, "tex_0" );
            gl.uniform1i( sampler_loc, 0 ); 
            
            set_uniform_vector3(gl, shader_program, "sun_dir", sun_dir.get_data());
            set_uniform_vector3(gl, shader_program, "sun_color", sun_color);

            set_uniform_int(gl, shader_program, "size", 0);
            //set_uniform_scalar_array(gl, shader_program, "a_point_pos", point_pos);
            //set_uniform_scalar_array(gl, shader_program, "a_point_color", point_color);
            set_uniform_scalar(gl, shader_program, "linear_scale", point_linear_scale)

            set_render_params( gl );
            
            requestAnimationFrame(render);

            function render(now) {
              requestAnimationFrame(render);

              let time_delta = ( now - last_update ) / 1000;
              last_update = now;
              total_delta += time_delta

              point_pos = [-1, -1, 0];
              set_uniform_scalar_array(gl, shader_program, "a_point_pos", point_pos);
              
              let transform = Mat4.translation(0, 0, 0);
              let xz_rotation = Model.getXZRotation(0);
              let model = transform.mul(xz_rotation);

              root.yaw_left(0.001);
              sphere.yaw_left(0.001);

              let view = camera.getView();

              let pos = [camera.x, camera.y, camera.z];
              set_uniform_vector3(gl, shader_program, "camera_pos", pos);
              
              let proj = projection.getFrustum();
              
              gl.clear( gl.COLOR_BUFFER_BIT );

              let jobs = [];
              generate_render_jobs( new Mat4, root, jobs);

              for ( let light of jobs ) {
                // load lights into scene
              }

              for( let job of jobs ) {
                draw(job.matrix, view.mul(job.matrix), proj, job.mesh);
              }
            }

            function draw( model, modelview, projection, mesh ) {
              set_vertex_attrib_to_buffer( 
                gl, mesh.program, 
                "coordinates", 
                mesh.verts, 3, 
                gl.FLOAT, false, UV_VERTEX_STRIDE, 0 
              );

              set_vertex_attrib_to_buffer( 
                gl, mesh.program, 
                "color", 
                mesh.verts, 4, 
                gl.FLOAT, false, UV_VERTEX_STRIDE, 12
              );

              set_vertex_attrib_to_buffer(
                gl, mesh.program,
                "uv",
                mesh.verts, 2,
                gl.FLOAT, false, UV_VERTEX_STRIDE, 28
              )

              set_vertex_attrib_to_buffer(
                gl, mesh.program,
                "normal",
                mesh.verts, 3,
                gl.FLOAT, false, UV_VERTEX_STRIDE, 36
              )

              gl.bindBuffer( gl.ARRAY_BUFFER, mesh.verts );
              gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, mesh.indis );
              
              set_uniform_matrix4(gl, shader_program, "model", model.data);
              set_uniform_matrix4(gl, shader_program, "modelview", modelview.data);
              set_uniform_matrix4(gl, shader_program, "projection", projection.data);

              mesh.material.load_material(gl, shader_program);
              //console.log(mesh);

              gl.drawElements( gl.TRIANGLES, mesh.n_indis, gl.UNSIGNED_SHORT, 0 );
            }

            function update() {
              camera.update(DESIRED_MSPT);
              projection.update(DESIRED_MSPT);
              update_labels();
            }

            function generate_render_jobs( parent_matrix, node, jobs ) {
              let matrix = parent_matrix.mul( node.get_matrix() );

              if( node.data != null ) { 
                jobs.push( new RenderMesh( matrix, node.data ) );
              }

              for( let child of node.children ) {
                generate_render_jobs( matrix, child, jobs );
              }
            }
        </script>
    </body>
</html>