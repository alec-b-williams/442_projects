<!DOCTYPE html>
<html>
    <head>
        <style>
            #the-canvas { border: 1px solid darkblue; }
            body {background-color: black; color: white;}
        </style>
    </head>

    <body>
        <canvas id = "the-canvas" width = "800" height = "600"></canvas>
        <br>
        <span id="fov_label"></span>
        <br>
        <span id="keys_label"></span>
        <br>
        <button onclick="toggle_inversion()">toggle</button><span id="inversion_label"></span><br>
        <span>Camera Position:</span><br>
        <span id="cam_x_label"></span><br>
        <span id="cam_y_label"></span><br>
        <span id="cam_z_label"></span><br>
        <span id="cam_roll_label"></span><br>
        <span id="cam_pitch_label"></span><br>
        <span id="cam_yaw_label"></span><br>  

        <script src = "src/lib.js"></script>
        <script src = "src/vector_lib.js"></script>
        <script src = "src/matrix_lib.js"></script>
        <script src = "src/mesh.js"></script>
        <script src = "src/input.js"></script>
        <script src = "src/model.js"></script>
        <script src = "src/view.js"></script>
        <script src = "src/projection.js"></script>
        <script src = "src/material.js"></script>
        <script src = "src/shaders.js"></script>
        <script src = "src/doc_util.js"></script>
        <script src = "src/node.js"></script>
        <script src = "src/render.js"></script>
                 
        <script>
            let canvas = document.getElementById( 'the-canvas' );
            
            /** @type {WebGLRenderingContext} */
            let gl = canvas.getContext( 'webgl2' );

            let shader_program = 
                create_compile_and_link_program( gl, Shaders.vertex_source, Shaders.fragment_source );

            const input = Keys.start_listening();
            let camera = new View(input);
            const projection = new Projection(input);

            const DESIRED_TICK_RATE = 60;
            const DESIRED_MSPT = 1000 / DESIRED_TICK_RATE;

            let last_update = performance.now();
            let total_delta = 0;

            let sun_dir = (new Vec4(1,0,0,0)).norm();
            let sun_color = [1,1,.85];

            let light_dist = 1;
            let fun = false;

            let point_linear_scale = 1.2;

            let metal_image = new Image();
            metal_image.src = "textures/earth.jpg";
            metal_image.onload = on_load;

            let root = new Node();

            let sphere = root.add_child();
            sphere.move_right(1);
            sphere.data = Mesh.uv_sphere(gl, shader_program, 32, new Material(.25, 1, 2, 4));

            let moon = sphere.add_child();
            moon.scale = new Vec4(.25,.25,.25,1);
            moon.move_right(.75);
            moon.data = Mesh.uv_sphere(gl, shader_program, 32, new Material(.25, 1, 2, 4));

            let light = moon.add_child();
            light.data = new Light([0.2, 0.8, 0.2]);

            let other_sphere = root.add_child();
            other_sphere.move_left(1);
            other_sphere.data = Mesh.uv_sphere(gl, shader_program, 8, new Material(.25, 1, 2, 4));

            let lamp = root.add_child();
            lamp.data = Mesh.uv_sphere(gl, shader_program, 8, new Material(.25, 1, 2, 4));
            lamp.scale = new Vec4(.25,.5,.25,1);

            let lamp_light = lamp.add_child();
            lamp_light.data = new Light([1, .2, .2]);

            setInterval(update, DESIRED_MSPT);

            gl.cullFace( gl.BACK );
            gl.enable( gl.CULL_FACE );
            
            gl.useProgram( shader_program );

            let tex = gl.createTexture();
            gl.bindTexture( gl.TEXTURE_2D, tex );

            gl.texImage2D(
              gl.TEXTURE_2D, 0, gl.RGBA,
              256, 256, 0,
              gl.RGBA, gl.UNSIGNED_BYTE, 
              xor_texture()
            );

            gl.generateMipmap(gl.TEXTURE_2D);
            
            const sampler_loc = gl.getUniformLocation( shader_program, "tex_0" );
            gl.uniform1i( sampler_loc, 0 ); 
            
            set_uniform_vector3(gl, shader_program, "sun_dir", sun_dir.get_data());
            set_uniform_vector3(gl, shader_program, "sun_color", sun_color);

            set_uniform_int(gl, shader_program, "size", 0);
            set_uniform_scalar(gl, shader_program, "linear_scale", point_linear_scale)

            set_render_params( gl );
            
            requestAnimationFrame(render);

            function render(now) {
              requestAnimationFrame(render);

              let time_delta = ( now - last_update ) / 1000;
              last_update = now;
              total_delta += time_delta
              
              let transform = Mat4.translation(0, 0, 0);
              let xz_rotation = Model.getXZRotation(0);
              let model = transform.mul(xz_rotation);

              root.yaw_left(0.001);
              sphere.yaw_left(0.001);
              other_sphere.roll_cw(0.002);
              other_sphere.yaw_right(0.003);

              let view = camera.get_view();

              let pos = [camera.x, camera.y, camera.z];
              set_uniform_vector3(gl, shader_program, "camera_pos", pos);
              
              let proj = projection.getFrustum();
              
              gl.clear( gl.COLOR_BUFFER_BIT );

              let jobs = [];
              let lights = [];
              generate_render_jobs( new Mat4, root, jobs, lights);

              let light_coords = [];
              let light_colors = [];
              for ( let light of lights ) {
                light_coords = light_coords.concat(light.position);
                light_colors = light_colors.concat(light.color);
              }
              set_uniform_int(gl, shader_program, "size", lights.length);
              set_uniform_scalar_array(gl, shader_program, "a_point_pos", light_coords);
              set_uniform_scalar_array(gl, shader_program, "a_point_color", light_colors);

              for( let job of jobs ) {
                draw(job.matrix, view.mul(job.matrix), proj, job.mesh);
              }
            }

            function draw( model, modelview, projection, mesh ) {
              set_vertex_attrib_to_buffer( 
                gl, mesh.program, 
                "coordinates", 
                mesh.verts, 3, 
                gl.FLOAT, false, UV_VERTEX_STRIDE, 0 
              );

              set_vertex_attrib_to_buffer( 
                gl, mesh.program, 
                "color", 
                mesh.verts, 4, 
                gl.FLOAT, false, UV_VERTEX_STRIDE, 12
              );

              set_vertex_attrib_to_buffer(
                gl, mesh.program,
                "uv",
                mesh.verts, 2,
                gl.FLOAT, false, UV_VERTEX_STRIDE, 28
              )

              set_vertex_attrib_to_buffer(
                gl, mesh.program,
                "normal",
                mesh.verts, 3,
                gl.FLOAT, false, UV_VERTEX_STRIDE, 36
              )

              gl.bindBuffer( gl.ARRAY_BUFFER, mesh.verts );
              gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, mesh.indis );
              
              set_uniform_matrix4(gl, shader_program, "model", model.data);
              set_uniform_matrix4(gl, shader_program, "modelview", modelview.data);
              set_uniform_matrix4(gl, shader_program, "projection", projection.data);

              mesh.material.load_material(gl, shader_program);

              gl.drawElements( gl.TRIANGLES, mesh.n_indis, gl.UNSIGNED_SHORT, 0 );
            }

            function update() {
              camera.update();
              projection.update(DESIRED_MSPT);
              update_labels();
            }

            function generate_render_jobs( parent_matrix, node, jobs, lights ) {
              let matrix = parent_matrix.mul( node.get_matrix() );

              if( node.data != null ) {
                if (node.data.constructor.name == "Light") {
                  let pos = matrix.transform(node.x,node.y,node.z,1)
                  lights.push( new RenderLight( [pos.x, pos.y, pos.z], node.data.color));
                } else {
                  jobs.push( new RenderMesh( matrix, node.data ) );
                }
                
              }

              for( let child of node.children ) {
                generate_render_jobs( matrix, child, jobs, lights );
              }
            }
        </script>
    </body>
</html>